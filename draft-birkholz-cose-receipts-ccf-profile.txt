



TBD                                                          H. Birkholz
Internet-Draft                                            Fraunhofer SIT
Intended status: Standards Track                      A. Delignat-Lavaud
Expires: 12 April 2025                                        C. Fournet
                                                             A. Chamayou
                                                      Microsoft Research
                                                          9 October 2024


                         COSE Receipts with CCF
            draft-birkholz-cose-receipts-ccf-profile-latest

Abstract

   This document defines a new verifiable data structure type for COSE
   Signed Merkle Tree Proofs specifically designed for transaction
   ledgers produced by Trusted Execution Environments (TEEs), such as
   the Confidential Consortium Framework ([CCF]) to provide stronger
   tamper-evidence guarantees.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Source for this draft and an issue tracker can be found at
   https://github.com/ietf-scitt/draft-birkholz-cose-cometre-ccf-
   profile.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 12 April 2025.

Copyright Notice

   Copyright (c) 2024 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Revised BSD License text as
   described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Revised BSD License.

Table of Contents

   1.  Introduction
     1.1.  Requirements Notation
   2.  Description of the CCF Ledger Verifiable Data Structure
     2.1.  Merkle Tree Shape
     2.2.  Transaction Components
   3.  CCF Inclusion Proofs
     3.1.  CCF Inclusion Proof Signature
     3.2.  Inclusion Proof Verification Algorithm
   4.  Privacy Considerations
   5.  Security Considerations
   6.  IANA Considerations
     6.1.  Additions to Existing Registries
       6.1.1.  Tree Algorithms
   7.  Normative References
   Appendix A.  Attic
   Authors' Addresses

1.  Introduction

   The COSE Receipts document [I-D.IETF-cose-merkle-tree-proofs] defines
   a common framework for defining different types of proofs, such as
   proof of inclusion, about verifiable data structures (VDS).  For
   instance, inclusion proofs guarantee to a verifier that a given
   serializable element is recorded at a given state of the VDS, while
   consistency proofs are used to establish that an inclusion proof is
   still consistent with the new state of the VDS at a later time.

   In this document, we define a new type of VDS, associated with the
   Confidential Consortium Framework (CCF) ledger.  This VDS carries
   indexed transaction information in a binary Merkle Tree, where new
   transactions are appended to the right, so that the binary
   decomposition of the index of a transaction can be interpreted as the
   position in the tree if 0 represents the left branch and 1 the right
   branch.  Compared to [RFC9162], the leaves of CCF trees carry
   additional internal information for the following purposes:

   1.  To bind the full details of the transaction executed, which is a
       super-set of what is exposed in the proof and captures internal
       information details useful for detailed system audit, but not for
       application purposes.

   2.  To verify that elements are only written by the Trusted Execution
       Environment, which addresses the persistence of committed
       transactions that happen between new signatures of the Merkle
       Tree root.

1.1.  Requirements Notation

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

2.  Description of the CCF Ledger Verifiable Data Structure

   This documents extends the verifiable data structure registry of
   [I-D.IETF-cose-merkle-tree-proofs] with the following value:

   +===================+===============+==================+===========+
   | Name              | Value         | Description      | Reference |
   +===================+===============+==================+===========+
   | CCF_LEDGER_SHA256 | TBD_1         | Historical       | This      |
   |                   | (requested    | transaction      | document  |
   |                   | assignment 2) | ledgers, such as |           |
   |                   |               | the CCF ledger   |           |
   +-------------------+---------------+------------------+-----------+

              Table 1: Verifiable Data Structure Algorithms

   This document defines inclusion proofs for CCF ledgers.  Verifiers
   MUST reject all other proof types

2.1.  Merkle Tree Shape

   A CCF ledger is a binary Merkle Tree constructed from a hash function
   H, which is defined from the log type.  For instance, the hash
   function for CCF_LEDGER_SHA256 is SHA256, whose HASH_SIZE is 32
   bytes.

   The Merkle tree encodes an ordered list of n transactions T_n =
   {T[0], T[1], ..., T[n-1]}. We define the Merkle Tree Hash (MTH)
   function, which takes as input a list of serialized transactions (as
   byte strings), and outputs a single HASH_SIZE byte string called the
   Merkle root hash, by induction on the list:

   This function is defined as follows:

   The hash of an empty list is the hash of an empty string:

   MTH({}) = HASH().

   The hash of a list with one entry (also known as a leaf hash) is:

   MTH({d[0]}) = HASH(d[0]).

   For n > 1, let k be the largest power of two smaller than n (i.e., k
   < n <= 2k).  The Merkle Tree Hash of an n-element list D_n is then
   defined recursively as:

   MTH(D_n) = HASH(MTH(D[0:k]) || MTH(D[k:n])),

   where:

   *  || denotes concatenation

   *  : denotes concatenation of lists

   *  D[k1:k2] = D'_(k2-k1) denotes the list {d'[0] = d[k1], d'[1] =
      d[k1+1], ..., d'[k2-k1-1] = d[k2-1]} of length (k2 - k1).

2.2.  Transaction Components

   Each leaf in a CCF ledger carries the following components:

ccf-leaf = [
  internal-transaction-hash: bstr .size 32 ; a string of HASH_SIZE(32) bytes
  internal-evidence: tstr .size (1..1024)  ; a string of at most 1024 bytes
  data-hash: bstr .size 32                 ; a string of HASH_SIZE(32) bytes
]

   The internal-transaction-hash and internal-evidence byte strings are
   internal to the CCF implementation.  They can be safely ignored by
   receipt Verifiers, but they commit the TS to the whole tree contents
   and may be used for additional, CCF-specific auditing.

   internal-transaction-hash is a hash over the complete entry in the
   [CCF-Ledger-Format], and internal-evidence is a revealable
   [CCF-Commit-Evidence] value that allows early persistence of ledger
   entries before distributed consensus can be established.

   data-hash summarises the subject of the proof: the data which is
   included in the ledger at this transaction.

3.  CCF Inclusion Proofs

   CCF inclusion proofs consist of a list of digests tagged with a
   single left-or-right bit.

ccf-proof-element = [
  left: bool         ; position of the element
  hash: bstr .size 32; hash of the proof element (string of HASH_SIZE(32) bytes)
]

ccf-inclusion-proof = bstr .cbor {
  &(leaf: 1) => ccf-leaf
  &(path: 2) => [+ ccf-proof-element]
}

   Unlike some other tree algorithms, the index of the element in the
   tree is not explicit in the inclusion proof, but the list of left-or-
   right bits can be treated as the binary decomposition of the index,
   from the least significant (leaf) to the most significant (root).

3.1.  CCF Inclusion Proof Signature

   The proof signature for a CCF inclusion proof is a COSE signature
   (encoded with the COSE_Sign1 CBOR type) which includes the following
   additional requirements for protected and unprotected headers.
   Please note that there may be additional headers defined by the
   application.

   The protected headers for the CCF inclusion proof signature MUST
   include the following:

   *  verifiable-data-structure: int/tstr.  This header MUST be set to
      the verifiable data structure algorithm identifier for ccf-ledger
      (TBD_1).

   *  label: int.  This header MUST be set to the value of the inclusion
      proof type in the IANA registry of Verifiable Data Structure Proof
      Type (-1).

   The unprotected header for a CCF inclusion proof signature MUST
   include the following:

   *  inclusion-proof: bstr .cbor ccf-inclusion-proof.  This contains
      the serialized CCF inclusion proof, as defined above.

   The payload of the signature is the CCF ledger Merkle root digest,
   and MUST be detached in order to force verifiers to recompute the
   root from the inclusion proof in the unprotected header.  This
   provides a safeguard against implementation errors that use the
   payload of the signature but do not recompute the root from the
   inclusion proof.

3.2.  Inclusion Proof Verification Algorithm

   CCF uses the following algorithm to verify an inclusion receipt:

compute_root(proof):
  h := proof.leaf.internal-transaction-hash
       || HASH(proof.leaf.internal-evidence)
       || proof.leaf.data-hash

  for [left, hash] in proof:
      h := HASH(hash + h) if left
           HASH(h + hash) else
  return h

verify_inclusion_receipt(inclusion_receipt):
  let proof = inclusion_receipt.unprotected_headers[INCLUSION_PROOF_LABEL] or fail
  assert(inclusion_receipt.payload == nil)
  let payload = compute_root(proof)

  # Use the Merkle Root as the detached payload
  return verify_cose(inclusion_receipt, payload)

   A description can also be found at [CCF-Receipt-Verification].

4.  Privacy Considerations

   Privacy Considerations

5.  Security Considerations

   Security Considerations

6.  IANA Considerations

6.1.  Additions to Existing Registries

6.1.1.  Tree Algorithms

   This document requests IANA to add the following new value to the
   'COSE Verifiable Data Structures' registry:

   *  Name: CCF_LEDGER_SHA256

   *  Value: TBD_1 (requested assignment 2)

   *  Description: Historical transaction ledgers produced by Trusted
      Execution Environments, such as the CCF ledger

   *  Reference: This document

7.  Normative References

   [CCF]      "Confidential Consortium Framework", n.d.,
              <https://github.com/microsoft/ccf>.

   [CCF-Commit-Evidence]
              "CCF Commit Evidence", n.d.,
              <https://microsoft.github.io/CCF/main/use_apps/
              verify_tx.html#commit-evidence>.

   [CCF-Ledger-Format]
              "CCF Ledger Format", n.d.,
              <https://microsoft.github.io/CCF/main/architecture/
              ledger.html>.

   [CCF-Receipt-Verification]
              "CCF Receipt Verification", n.d.,
              <https://microsoft.github.io/CCF/main/use_apps/
              verify_tx.html#receipt-verification>.

   [I-D.IETF-cose-merkle-tree-proofs]
              "*** BROKEN REFERENCE ***".

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://www.rfc-editor.org/rfc/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/rfc/rfc8174>.

   [RFC9162]  Laurie, B., Messeri, E., and R. Stradling, "Certificate
              Transparency Version 2.0", RFC 9162, DOI 10.17487/RFC9162,
              December 2021, <https://www.rfc-editor.org/rfc/rfc9162>.

Appendix A.  Attic

   Not ready to throw these texts into the trash bin yet.

Authors' Addresses

   Henk Birkholz
   Fraunhofer SIT
   Rheinstrasse 75
   64295 Darmstadt
   Germany
   Email: henk.birkholz@sit.fraunhofer.de


   Antoine Delignat-Lavaud
   Microsoft Research
   21 Station Road
   Cambridge
   CB1 2FB
   United Kingdom
   Email: antdl@microsoft.com


   Cedric Fournet
   Microsoft Research
   21 Station Road
   Cambridge
   CB1 2FB
   United Kingdom
   Email: fournet@microsoft.com


   Amaury Chamayou
   Microsoft Research
   21 Station Road
   Cambridge
   CB1 2FB
   United Kingdom
   Email: amaury.chamayou@microsoft.com
